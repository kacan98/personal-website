import { JobCvIntersectionResponse, JobCVIntersectionResponse } from '@/app/api/job-cv-intersection/model'
import { CVSettings } from '@/types'
import OpenAI from 'openai'
import { zodResponseFormat } from 'openai/helpers/zod.mjs'
import { z } from 'zod'
import { OPENAI_API_KEY } from '@/lib/env'
import { OPENAI_MODELS } from '@/lib/openai-service'

// Position summary response schema
const PositionSummarizeResponse = z.object({
  summary: z.string(),
  companyName: z.string().nullable().optional(),
  languagePostIsWrittineIn: z.string(),
})

type PositionSummarizeResponseType = z.infer<typeof PositionSummarizeResponse>

export interface PositionAnalysisResult {
  positionSummary?: string
  companyName?: string | null
  jobIntersection?: JobCvIntersectionResponse
}

export class PositionAnalysisService {
  /**
   * Run position summary and job intersection analysis in parallel
   * Now directly calls OpenAI instead of making HTTP requests to avoid Vercel auth issues
   */
  static async analyzePosition(
    jobDescription: string,
    cvData: CVSettings,
    request?: Request,
    options?: {
      skipSummary?: boolean
      skipIntersection?: boolean
    }
  ): Promise<PositionAnalysisResult> {
    const needsSummary = !options?.skipSummary
    const needsIntersection = !options?.skipIntersection

    if (!needsSummary && !needsIntersection) {
      return {}
    }

    if (!OPENAI_API_KEY) {
      throw new Error('OpenAI API key not configured')
    }

    console.log('PositionAnalysisService - Running analysis tasks in parallel')

    const openai = new OpenAI({
      apiKey: OPENAI_API_KEY,
    })

    const tasks: Promise<any>[] = []

    // Position summary task - direct OpenAI call
    if (needsSummary) {
      const positionSummaryTask = openai.chat.completions.parse({
        model: OPENAI_MODELS.LATEST_MINI,
        messages: [
          {
            role: 'user',
            content: `You are a hiring manager for this position:`,
          },
          {
            role: 'user',
            content: jobDescription,
          },
          {
            role: 'user',
            content:
              'Please take out what is the most imporatant about the candidate you are going to hire?',
          },
          {
            role: 'user',
            content:
              'Be brief and to the point. Return it in a json object with the summary and the company name if available.',
          },
        ],
        response_format: zodResponseFormat(PositionSummarizeResponse, 'transformed_cv'),
      }).then(completion => {
        const parsed = completion.choices[0].message.parsed
        if (!parsed) {
          throw new Error('No summary generated by OpenAI')
        }
        return parsed as PositionSummarizeResponseType
      })
      tasks.push(positionSummaryTask)
    }

    // Job intersection task - direct OpenAI call
    if (needsIntersection) {
      const jobIntersectionTask = openai.chat.completions.parse({
        model: OPENAI_MODELS.LATEST_MINI,
        messages: [
          {
            role: 'user',
            content: `You are a hiring manager for this position:`,
          },
          {
            role: 'user',
            content: jobDescription,
          },
          {
            role: 'user',
            content: 'And here is a candidate:',
          },
          {
            role: 'user',
            content: JSON.stringify(cvData),
          },
          {
            role: 'user',
            content: `What do you think about this candidate?
            Say your opinion, what is missing in the CV? What is good about the CV?
            Rate the candidate from 1 to 10.

            Make sure to return this in a json format as described.

            Be brief and to the point. Lists are good.
            `,
          },
        ],
        response_format: zodResponseFormat(JobCVIntersectionResponse, 'transformed_cv'),
      }).then(response => {
        const parsed = response.choices[0].message.parsed
        if (!parsed) {
          throw new Error('No analysis generated by OpenAI')
        }
        return parsed
      })
      tasks.push(jobIntersectionTask)
    }

    try {
      const results = await Promise.all(tasks)

      const result: PositionAnalysisResult = {}
      let resultIndex = 0

      if (needsSummary) {
        const positionResult = results[resultIndex++] as PositionSummarizeResponseType
        result.positionSummary = positionResult.summary
        result.companyName = positionResult.companyName
        console.log('PositionAnalysisService - Position summary completed')
      }

      if (needsIntersection) {
        result.jobIntersection = results[resultIndex++]
        console.log('PositionAnalysisService - Job intersection completed')
      }

      console.log('PositionAnalysisService - Analysis tasks completed')
      return result
    } catch (e) {
      console.error('PositionAnalysisService - Analysis failed:', e)
      throw new Error(`Failed to complete position analysis: ${e instanceof Error ? e.message : 'Unknown error'}`)
    }
  }
}